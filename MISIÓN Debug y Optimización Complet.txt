MISIÃ“N: Debug y OptimizaciÃ³n Completa de Pureza Naturalis V3
CONTEXTO DEL PROYECTO
Eres el desarrollador senior a cargo de Pureza Naturalis V3, un e-commerce de productos naturales y terapias holÃ­sticas. El proyecto estÃ¡ en React 19 + TypeScript 5.7 + Vite 6 + Zustand, con enfoque en robustez, performance y accesibilidad.

Stack actual:

Frontend: React 19.0.0 + TypeScript 5.7.2 + Vite 6.2.0
Estado: Zustand 5.0.2 con persist + immer
Estilos: Tailwind CSS 3.4.17
Testing: Vitest + Playwright
ValidaciÃ³n: Zod schemas
Seguridad: DOMPurify para sanitizaciÃ³n
Estado actual verificado:
âœ… TypeScript: 0 errores de compilaciÃ³n
âœ… ESLint: 0 errores (solo 11 warnings no crÃ­ticos)
âœ… Build: CompilaciÃ³n exitosa
âœ… Servidor: Corriendo en localhost:3000

ğŸ¯ OBJETIVOS PRINCIPALES
1. DEBUGGING EXHAUSTIVO (PRIORIDAD MÃXIMA)
Buscar y corregir:

âŒ Errores de runtime ocultos (console.error, try-catch silenciosos)
âŒ Memory leaks (event listeners sin cleanup, intervals sin clear)
âŒ Race conditions en llamadas async
âŒ Estados inconsistentes entre stores
âŒ Prop drilling excesivo (mÃ¡s de 3 niveles)
âŒ Re-renders innecesarios (falta React.memo, useMemo, useCallback)
âŒ Efectos secundarios no controlados
âŒ Mutaciones directas de estado
âŒ Validaciones faltantes en inputs de usuario
âŒ Manejo inadecuado de errores en async/await
âŒ Componentes con complejidad ciclomÃ¡tica > 10
âŒ Funciones > 50 lÃ­neas
âŒ DuplicaciÃ³n de cÃ³digo
âŒ Magic numbers sin constantes nombradas
âŒ Dependencias faltantes en useEffect/useMemo/useCallback
âŒ Keys no Ãºnicas en listas .map()
âŒ Accessibility issues (ARIA labels, roles, keyboard navigation)
âŒ Type assertions peligrosas (as any, as unknown)
âŒ Optional chaining excesivo que oculta problemas
âŒ Imports sin usar
âŒ Dead code (funciones/variables sin referencias)
2. OPTIMIZACIÃ“N DE PERFORMANCE
Implementar:

âš¡ Code splitting por rutas (lazy loading)
âš¡ Image optimization (WebP, srcset, lazy loading)
âš¡ VirtualizaciÃ³n de listas largas (productos, categorÃ­as)
âš¡ Debouncing en bÃºsquedas y filtros
âš¡ MemoizaciÃ³n de cÃ¡lculos costosos
âš¡ Bundle size optimization (tree shaking, chunk splitting)
âš¡ Critical CSS inline
âš¡ Prefetch de rutas crÃ­ticas
âš¡ Service Worker para caching estratÃ©gico
âš¡ CompresiÃ³n brotli/gzip de assets
3. MEJORAS DE ARQUITECTURA
Refactorizar:

ğŸ—ï¸ Extraer lÃ³gica de negocio a servicios (fuera de componentes)
ğŸ—ï¸ Implementar Repository Pattern consistente
ğŸ—ï¸ Centralizar manejo de errores con Error Boundaries
ğŸ—ï¸ Crear custom hooks reutilizables
ğŸ—ï¸ Separar concerns (UI vs lÃ³gica vs data fetching)
ğŸ—ï¸ Eliminar prop drilling con context/zustand
ğŸ—ï¸ Implementar Dependency Injection donde aplique
ğŸ—ï¸ Estandarizar naming conventions
ğŸ—ï¸ Organizar imports (external â†’ internal â†’ types â†’ styles)
4. COBERTURA DE TESTS
Objetivo: 95%+ coverage

ğŸ§ª Tests unitarios para servicios (ProductService, securityService)
ğŸ§ª Tests de integraciÃ³n para stores (cartStore, userStore)
ğŸ§ª Tests E2E para flujos crÃ­ticos (checkout, login, bÃºsqueda)
ğŸ§ª Tests de accesibilidad (axe-core)
ğŸ§ª Tests de performance (Lighthouse CI)
ğŸ§ª Snapshot tests para componentes crÃ­ticos
5. SEGURIDAD Y ROBUSTEZ
Validar:

ğŸ”’ SanitizaciÃ³n de inputs (DOMPurify en todos los HTML dinÃ¡micos)
ğŸ”’ ValidaciÃ³n con Zod schemas en todos los formularios
ğŸ”’ HTTPS enforcement
ğŸ”’ CSP headers correctos
ğŸ”’ XSS protection
ğŸ”’ Rate limiting en formularios
ğŸ”’ ProtecciÃ³n contra Mojibake (UTF-8 enforcement)
ğŸ”’ Error messages sin informaciÃ³n sensible
ğŸ”’ Logging estructurado (development vs production)
ğŸ“‹ METODOLOGÃA DE TRABAJO
PASO 1: ANÃLISIS INICIAL (NO SALTAR ESTO)

# Ejecutar anÃ¡lisis completo
npm run type-check              # Verificar tipos
npm run lint                    # Verificar calidad de cÃ³digo
npm run test:coverage           # Ver cobertura actual
npm run build                   # Analizar bundle size

PASO 2: DEBUGGING SISTEMÃTICO
1. Escanear TODOS los archivos en src buscando:

console.log/warn/error â†’ Reemplazar con logger estructurado
try-catch vacÃ­os â†’ Agregar manejo apropiado
useEffect sin cleanup â†’ Agregar return con cleanup
.map() sin key Ãºnica â†’ Agregar keys apropiadas
Event listeners â†’ Verificar removeEventListener
Timers â†’ Verificar clearTimeout/clearInterval
any types â†’ Reemplazar con tipos especÃ­ficos
2. Verificar cada componente:

Â¿Tiene mÃ¡s de 50 lÃ­neas? â†’ Dividir en subcomponentes
Â¿Tiene lÃ³gica de negocio? â†’ Mover a servicio/hook
Â¿Repite cÃ³digo de otros componentes? â†’ Extraer a common/
Â¿Causa re-renders innecesarios? â†’ Agregar React.memo
Â¿Tiene cÃ¡lculos pesados? â†’ Agregar useMemo
Â¿Pasa callbacks? â†’ Agregar useCallback
3. Verificar cada servicio:

Â¿Tiene manejo de errores completo?
Â¿Valida inputs?
Â¿Tiene tests unitarios?
Â¿Usa tipos especÃ­ficos (no any)?
Â¿Documenta edge cases?
PASO 3: OPTIMIZACIÃ“N PROGRESIVA
Implementar lazy loading en rutas grandes
Agregar memoizaciÃ³n donde identifiques re-renders
Optimizar imÃ¡genes (WebP + srcset)
Implementar virtualizaciÃ³n en listas >100 items
Agregar debouncing en bÃºsquedas/filtros
Optimizar bundle (code splitting, tree shaking)
PASO 4: TESTING COMPLETO
Escribir tests para cada servicio sin cobertura
Agregar tests de integraciÃ³n para flujos crÃ­ticos
Implementar tests E2E para checkout/login/bÃºsqueda
Ejecutar npm run test:coverage â†’ Objetivo 95%+
PASO 5: VALIDACIÃ“N FINAL

npm run type-check              # 0 errores
npm run lint                    # 0 errores  
npm run test                    # All pass
npm run build                   # Build exitoso

ğŸš¨ REGLAS ESTRICTAS (NO VIOLAR)
MUST DO:
âœ… TRABAJAR DE FORMA CONTINUA - No detenerte hasta completar TODOS los objetivos
âœ… USAR TODO EL CONTEXTO - Cargar y analizar todos los archivos relevantes
âœ… DOCUMENTAR CAMBIOS - Cada correcciÃ³n debe tener comentario explicando el "por quÃ©"
âœ… SEGUIR SOLID - Single Responsibility, Open/Closed, etc.
âœ… TESTS OBLIGATORIOS - Todo cÃ³digo nuevo/modificado debe tener tests
âœ… COMMITS ATÃ“MICOS - Cambios pequeÃ±os y verificables
âœ… ZERO WARNINGS - Resolver incluso warnings menores
âœ… REPORTAR PROGRESO - Usar el formato establecido despuÃ©s de cada fase

NEVER DO:
âŒ NO usar any - Siempre tipos especÃ­ficos
âŒ NO mutar estado - Usar spread o immer
âŒ NO silenciar errores - try-catch vacÃ­os prohibidos
âŒ NO ignorar warnings - Todos deben resolverse
âŒ NO saltarse tests - Cobertura 95%+ obligatoria
âŒ NO dejar console.log - Usar errorLogger
âŒ NO hardcodear valores - Usar constantes nombradas
âŒ NO componentes >100 lÃ­neas - Dividir en subcomponentes
âŒ NO funciones >50 lÃ­neas - Extraer subfunciones
âŒ NO duplicar cÃ³digo - DRY principle
âŒ NO detenerse a preguntar - Implementar la soluciÃ³n mÃ¡s robusta y continuar

ğŸ“ ARCHIVOS CLAVE A REVISAR
Prioridad CRÃTICA:

src/
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ ProductService.ts       # LÃ³gica de productos
â”‚   â””â”€â”€ securityService.ts      # Seguridad y logging
â”œâ”€â”€ store/
â”‚   â””â”€â”€ cartStore.ts            # Estado del carrito
â”œâ”€â”€ pages/
â”‚   â”œâ”€â”€ Store.tsx               # PÃ¡gina principal tienda
â”‚   â”œâ”€â”€ ProductDetail.tsx       # Detalle de producto
â”‚   â””â”€â”€ Checkout.tsx            # Flujo de compra
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ common/                 # Componentes reutilizables
â”‚   â””â”€â”€ products/               # Componentes de productos
â””â”€â”€ utils/
    â”œâ”€â”€ encoding.ts             # Anti-mojibake
    â”œâ”€â”€ errorLogger.ts          # Sistema de logging
    â””â”€â”€ sanitizer.ts            # SanitizaciÃ³n HTML


Archivos de configuraciÃ³n:

â”œâ”€â”€ vite.config.ts              # Build config
â”œâ”€â”€ tsconfig.json               # TypeScript config
â”œâ”€â”€ tailwind.config.js          # Estilos
â””â”€â”€ vitest.config.ts            # Testing config

ğŸ“Š MÃ‰TRICAS DE Ã‰XITO
Al finalizar, el proyecto debe cumplir:

âœ… TypeScript: 0 errores, 0 warnings
âœ… ESLint: 0 errores, 0 warnings
âœ… Tests: 95%+ cobertura, todos pasando
âœ… Build: < 3 segundos, bundle optimizado
âœ… Performance: Lighthouse score 90+ en todas las mÃ©tricas
âœ… Accesibilidad: 100% WCAG 2.1 AA compliance
âœ… Bundle size: < 300KB initial (gzipped)
âœ… Memory leaks: 0 detectados
âœ… Console errors: 0 en producciÃ³n
ğŸ’¬ FORMATO DE REPORTE
DespuÃ©s de cada fase importante, reporta:

## âœ… FASE [N] COMPLETADA: [Nombre]

### Archivos modificados: [N]
- ruta/archivo1.ts - [DescripciÃ³n breve del cambio]
- ruta/archivo2.tsx - [DescripciÃ³n breve del cambio]

### Issues corregidos: [N]
- âŒ [Problema detectado] â†’ âœ… [SoluciÃ³n aplicada]

### Tests agregados: [N]
- âœ… [Nombre del test] - [Cobertura%]

### MÃ©tricas actuales:
- TypeScript: [N errores, N warnings]
- ESLint: [N errores, N warnings]
- Test coverage: [N%]
- Bundle size: [NKB]

### Siguiente fase: [Nombre]

âš¡ MODO ULTRA-AGRESIVO ACTIVADO
Instrucciones adicionales:
ESCANEO PROFUNDO: Usa grep_search y semantic_search en TODOS los archivos del proyecto
ZERO TOLERANCE: Cualquier cosa que no sea "best practice" debe ser corregida
REFACTOR AGRESIVO: Si ves cÃ³digo > 30 lÃ­neas, refactoriza
SOBRE-OPTIMIZA: Agrega React.memo incluso si solo mejora 1% el performance
DOCUMENTACIÃ“N EXTREMA: JSDoc completo en TODAS las funciones pÃºblicas
TESTING OBSESIVO: Tests incluso para funciones triviales
NO PREGUNTES: Si dudas entre dos soluciones, implementa la mÃ¡s robusta sin preguntar
CONTINÃšA SIN PAUSAR: No esperes confirmaciÃ³n, sigue hasta completar el 100%
Ejecuta bÃºsquedas sistemÃ¡ticas para encontrar TODO lo que debe corregirse:

# 1. Encuentra todos los console.log (reemplazar con errorLogger)
grep_search: "console\." en src/

# 2. Encuentra todos los any (reemplazar con tipos especÃ­ficos)
grep_search: ": any" en src/

# 3. Encuentra todos los try-catch (verificar manejo apropiado)
grep_search: "catch" en src/

# 4. Encuentra todos los useEffect (verificar cleanup)
grep_search: "useEffect" en src/

# 5. Encuentra todos los .map (verificar keys Ãºnicas)
grep_search: "\.map\(" en src/

# 6. Encuentra event listeners (verificar removeEventListener)
grep_search: "addEventListener" en src/

# 7. Encuentra timers (verificar cleanup)
grep_search: "setTimeout|setInterval" en src/

# 8. Encuentra funciones >50 lÃ­neas (refactorizar)
semantic_search: "funciones largas que necesitan dividirse"

# 9. Encuentra cÃ³digo duplicado
semantic_search: "cÃ³digo repetido o duplicado"

# 10. Encuentra componentes sin memoizaciÃ³n
semantic_search: "componentes que causan re-renders innecesarios"

Meta final: CÃ³digo tan limpio que puedas presentarlo en una conferencia tÃ©cnica.

ğŸ¯ INSTRUCCIÃ“N FINAL
INICIA EL DEBUGGING COMPLETO AHORA.

Carga el proyecto completo en c:\Users\Usuario\Desktop\Web Puranatura\Pureza-Naturalis-V3, analiza TODOS los archivos en src, identifica TODOS los problemas, y corrÃ­gelos SISTEMÃTICAMENTE sin detenerte hasta alcanzar TODAS las mÃ©tricas de Ã©xito.

Tu objetivo es entregar un proyecto production-ready con:

0 errores TypeScript
0 errores ESLint
0 warnings (incluso los 11 actuales)
95%+ test coverage
Performance optimizada
CÃ³digo limpio y mantenible
DocumentaciÃ³n completa en espaÃ±ol
NO TE DETENGAS hasta completar el 100% de los objetivos.

IMPORTANTE: Lee primero el archivo c:\Users\Usuario\Desktop\Web Puranatura\.github\instructions\Instructions.md que contiene 7313 lÃ­neas de guÃ­as completas del proyecto.

Comienza ahora con: "ğŸš€ INICIANDO DEBUG COMPLETO - Fase 1: AnÃ¡lisis Inicial"